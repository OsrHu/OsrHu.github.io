<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>albert</title>
    <url>/%E8%AE%BA%E6%96%87/1/</url>
    <content><![CDATA[<h3 id="1-1-Factorized-embedding-parameterization"><a href="#1-1-Factorized-embedding-parameterization" class="headerlink" title="1.1 Factorized embedding parameterization"></a>1.1 Factorized embedding parameterization</h3><ol>
<li>从建模角度来讲，wordpiece向量应该是不依赖于当前内容的(context-independent)，而transformer所学习到的表示应该是依赖内容的。所以把E和H分开可以更高效地利用参数，因为理论上存储了context信息的<strong>H要远大于E</strong>。</li>
<li>从实践角度来讲，NLP任务中的vocab size本来就很大，如果E=H的话，模型参数量就容易很大，而且embedding在实际的训练中更新地也比较稀疏。</li>
</ol>
<p>因此作者使用了小一些的E(64、128、256、768)，训练一个独立于上下文的embedding(VxE)，之后计算时再投影到隐层的空间(乘上一个ExH的矩阵)，相当于做了一个因式分解。</p>
<h3 id="1-2-Cross-layer-parameter-sharing"><a href="#1-2-Cross-layer-parameter-sharing" class="headerlink" title="1.2 Cross-layer parameter sharing"></a>1.2 Cross-layer parameter sharing</h3><p>跨层参数共享</p>
<h3 id="1-3Inter-sentence-coherence-loss"><a href="#1-3Inter-sentence-coherence-loss" class="headerlink" title="1.3Inter-sentence coherence loss"></a>1.3Inter-sentence coherence loss</h3><p>NSP替换成SOP(sentence order prediction)，预测两句话有没有被交换过顺序</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/something/1/</url>
    <content><![CDATA[ <img src="https://cdn.osrhu.xyz/images/0.jpg">

<p>“总有一天你将破蛹而出，成长得比人们期待的还要美丽。<br>但这个过程会很痛，会很辛苦，有时候还会觉得灰心。<br>面对着汹涌而来的现实，觉得自己渺小无力。<br>但这，也是生命的一部分。做好现在你能做的，然后，一切都会好的。<br>我们都将孤独地长大，不要害怕。”</p>
]]></content>
      <categories>
        <category>something</category>
      </categories>
  </entry>
  <entry>
    <title>os1</title>
    <url>/os/os1/</url>
    <content><![CDATA[<h1 id="底层知识问题"><a href="#底层知识问题" class="headerlink" title="底层知识问题"></a>底层知识问题</h1><ul>
<li>Nginx的高并发性为什么能实现？</li>
<li>MySql的IO性能到底怎样提升？</li>
<li>Redis中经典的Reactor设计模式由什么技术支撑？</li>
<li>Node.js 的 I/O 模型长什么样？</li>
</ul>
<table>
<thead>
<tr>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>基础铺垫阶段</td>
</tr>
<tr>
<td>硬件</td>
</tr>
<tr>
<td>同步原语</td>
</tr>
<tr>
<td>初始化</td>
</tr>
<tr>
<td>内存管理</td>
</tr>
<tr>
<td>进程管理</td>
</tr>
<tr>
<td>设备I/O</td>
</tr>
<tr>
<td>文件系统</td>
</tr>
<tr>
<td>网络与API</td>
</tr>
<tr>
<td>前沿扩展</td>
</tr>
</tbody></table>
<h2 id="Hello-OS引导流程图"><a href="#Hello-OS引导流程图" class="headerlink" title="Hello OS引导流程图"></a>Hello OS引导流程图</h2> <img src="https://cdn.osrhu.xyz/images/os1.assets\image-20211219110026128.png">

<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡有多种形式：集成在主板上的叫集显，坐在CPU芯片内的叫核显，独立存在通过PCIE接口连接的叫独显，性能依次上升，价格也依次上升。</p>
<h3 id="计算机显卡文本模式"><a href="#计算机显卡文本模式" class="headerlink" title="计算机显卡文本模式"></a>计算机显卡文本模式</h3> <img src="https://cdn.osrhu.xyz/images/os1.assets\image-20211219110007917.png">

<h2 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h2><p>make是一个工具程序，它读取一个叫“makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件。</p>
<p>makefile文件中规则：首先由一个或者多个构建目标称为“target”；目标后面紧跟着用于构建该目标所需要的文件，目标下面是构建该目标所需要的命令及参数。另外，它会检查文件的依赖关系，需要的话，也会调用一些外部软件来完成这些任务。</p>
<p>第一次构建目标后，下一次执行 make 时，它会根据该目标所依赖的文件是否更新决定是否编译该目标，如果所依赖的文件没有更新且该目标又存在，那么它便不会构建该目标。这种特性非常有利于编译程序源代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC = gcc #定义一个宏CC 等于gcc</span><br><span class="line">CFLAGS = -c #定义一个宏 CFLAGS 等于-c</span><br><span class="line">OBJS_FILE = file.o file1.o file2.o file3.o file4.o #定义一个宏</span><br><span class="line">.PHONY : all everything #定义两个伪目标all、everything</span><br><span class="line">all:everything #伪目标all依赖于伪目标everything</span><br><span class="line">everything :$(OBJS_FILE) #伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被</span><br><span class="line">#替换成file.o file1.o file2.o file3.o file4.o</span><br><span class="line">%.o : %.c</span><br><span class="line">   $(CC) $(CFLAGS) -o $@ $&lt;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2> <img src="https://cdn.osrhu.xyz/images/os1.assets\image-20211219111246270.png">

]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
</search>
