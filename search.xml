<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>albert</title>
    <url>/%E8%AE%BA%E6%96%87/1/</url>
    <content><![CDATA[<h3 id="1-1-Factorized-embedding-parameterization"><a href="#1-1-Factorized-embedding-parameterization" class="headerlink" title="1.1 Factorized embedding parameterization"></a>1.1 Factorized embedding parameterization</h3><ol>
<li>从建模角度来讲，wordpiece向量应该是不依赖于当前内容的(context-independent)，而transformer所学习到的表示应该是依赖内容的。所以把E和H分开可以更高效地利用参数，因为理论上存储了context信息的<strong>H要远大于E</strong>。</li>
<li>从实践角度来讲，NLP任务中的vocab size本来就很大，如果E=H的话，模型参数量就容易很大，而且embedding在实际的训练中更新地也比较稀疏。</li>
</ol>
<p>因此作者使用了小一些的E(64、128、256、768)，训练一个独立于上下文的embedding(VxE)，之后计算时再投影到隐层的空间(乘上一个ExH的矩阵)，相当于做了一个因式分解。</p>
<h3 id="1-2-Cross-layer-parameter-sharing"><a href="#1-2-Cross-layer-parameter-sharing" class="headerlink" title="1.2 Cross-layer parameter sharing"></a>1.2 Cross-layer parameter sharing</h3><p>跨层参数共享</p>
<h3 id="1-3Inter-sentence-coherence-loss"><a href="#1-3Inter-sentence-coherence-loss" class="headerlink" title="1.3Inter-sentence coherence loss"></a>1.3Inter-sentence coherence loss</h3><p>NSP替换成SOP(sentence order prediction)，预测两句话有没有被交换过顺序</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>os1</title>
    <url>/os/os1/</url>
    <content><![CDATA[<h1 id="底层知识问题"><a href="#底层知识问题" class="headerlink" title="底层知识问题"></a>底层知识问题</h1><ul>
<li>Nginx的高并发性为什么能实现？</li>
<li>MySql的IO性能到底怎样提升？</li>
<li>Redis中经典的Reactor设计模式由什么技术支撑？</li>
<li>Node.js 的 I/O 模型长什么样？</li>
</ul>
<table>
<thead>
<tr>
<th>知识点</th>
</tr>
</thead>
<tbody><tr>
<td>基础铺垫阶段</td>
</tr>
<tr>
<td>硬件</td>
</tr>
<tr>
<td>同步原语</td>
</tr>
<tr>
<td>初始化</td>
</tr>
<tr>
<td>内存管理</td>
</tr>
<tr>
<td>进程管理</td>
</tr>
<tr>
<td>设备I/O</td>
</tr>
<tr>
<td>文件系统</td>
</tr>
<tr>
<td>网络与API</td>
</tr>
<tr>
<td>前沿扩展</td>
</tr>
</tbody></table>
<h2 id="Hello-OS引导流程图"><a href="#Hello-OS引导流程图" class="headerlink" title="Hello OS引导流程图"></a>Hello OS引导流程图</h2> <img src="https://cdn.osrhu.xyz/images/os1.assets\image-20211219110026128.png">

<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡有多种形式：集成在主板上的叫集显，坐在CPU芯片内的叫核显，独立存在通过PCIE接口连接的叫独显，性能依次上升，价格也依次上升。</p>
<h3 id="计算机显卡文本模式"><a href="#计算机显卡文本模式" class="headerlink" title="计算机显卡文本模式"></a>计算机显卡文本模式</h3> <img src="https://cdn.osrhu.xyz/images/os1.assets\image-20211219110007917.png">

<h2 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h2><p>make是一个工具程序，它读取一个叫“makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件。</p>
<p>makefile文件中规则：首先由一个或者多个构建目标称为“target”；目标后面紧跟着用于构建该目标所需要的文件，目标下面是构建该目标所需要的命令及参数。另外，它会检查文件的依赖关系，需要的话，也会调用一些外部软件来完成这些任务。</p>
<p>第一次构建目标后，下一次执行 make 时，它会根据该目标所依赖的文件是否更新决定是否编译该目标，如果所依赖的文件没有更新且该目标又存在，那么它便不会构建该目标。这种特性非常有利于编译程序源代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC = gcc #定义一个宏CC 等于gcc</span><br><span class="line">CFLAGS = -c #定义一个宏 CFLAGS 等于-c</span><br><span class="line">OBJS_FILE = file.o file1.o file2.o file3.o file4.o #定义一个宏</span><br><span class="line">.PHONY : all everything #定义两个伪目标all、everything</span><br><span class="line">all:everything #伪目标all依赖于伪目标everything</span><br><span class="line">everything :$(OBJS_FILE) #伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被</span><br><span class="line">#替换成file.o file1.o file2.o file3.o file4.o</span><br><span class="line">%.o : %.c</span><br><span class="line">   $(CC) $(CFLAGS) -o $@ $&lt;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2> <img src="https://cdn.osrhu.xyz/images/os1.assets\image-20211219111246270.png">

]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/something/1/</url>
    <content><![CDATA[ <img src="https://cdn.osrhu.xyz/images/0.jpg">

<p>“总有一天你将破蛹而出，成长得比人们期待的还要美丽。<br>但这个过程会很痛，会很辛苦，有时候还会觉得灰心。<br>面对着汹涌而来的现实，觉得自己渺小无力。<br>但这，也是生命的一部分。做好现在你能做的，然后，一切都会好的。<br>我们都将孤独地长大，不要害怕。”</p>
]]></content>
      <categories>
        <category>something</category>
      </categories>
  </entry>
  <entry>
    <title>os2</title>
    <url>/os/os2/</url>
    <content><![CDATA[<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>抽象角度来看：内核就是计算机资源的管理者，管理资源就是为了让应用使用资源。</p>
<h2 id="计算机资源"><a href="#计算机资源" class="headerlink" title="计算机资源"></a>计算机资源</h2><ul>
<li><p>硬件资源</p>
<ul>
<li>总线：负责链接各种其他设备，是其他设备工作的基础</li>
<li>CPU，中央处理器，负责执行程序和处理数据计算</li>
<li>内存，负责存储运行时的代码和数据</li>
<li>硬盘，负责长久存储用户文件数据</li>
<li>网卡，负责计算机与计算机之间的通信</li>
<li>显卡，负责显示工作</li>
<li>各种I/O设备，如显示器，打印机，键盘和鼠标…</li>
</ul>
 <img src="https://cdn.osrhu.xyz/images/os2.assets\28cc064d767d792071a789a5b4e7d714-16398885471692.jpg"></li>
<li><p>软件资源：各种形式的数据，如各种文件、软件程序等</p>
</li>
</ul>
<p>内核作为硬件资源和软件资源的管理者，其内部组成在逻辑上大致如下：</p>
<ul>
<li><p>管理CPU，由于 CPU 是执行程序的，而内核把运行时的程序抽象成进程，所以又称为进程管理。</p>
</li>
<li><p>管理内存，由于程序和数据都要占用内存，内存是非常宝贵的资源，所以内核要非常小心地分配、释放内存。</p>
</li>
<li><p>管理硬盘，硬盘主要存放用户数据，而内核把用户数据抽象成文件，即管理文件，文件需要合理地组织，方便用户查找和读写，所以形成了文件系统。</p>
</li>
<li><p>管理显卡，负责显示信息，而现在操作系统都是支持 GUI（图形用户接口）的，管理显卡自然而然地就成了内核中的图形系统。</p>
</li>
<li><p>管理网卡，网卡主要完成网络通信，网络通信需要各种通信协议，最后在内核中就形成了网络协议栈，又称网络组件。</p>
</li>
<li><p>管理各种I/O设备，我们经常把键盘、鼠标、打印机、显示器等统称为 I/O（输入输出）设备，在内核中抽象成 I/O 管理器。</p>
<p>另外 驱动程序是内核与硬件之间的桥梁</p>
</li>
</ul>
<h2 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h2><h3 id="宏内核结构"><a href="#宏内核结构" class="headerlink" title="宏内核结构"></a>宏内核结构</h3><p>宏内核就是把以上诸如管理进程的代码、管理内存的代码、管理各种 I/O 设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码，把这些所有的代码经过编译，最后链接在一起，形成一个大的可执行程序。</p>
<p>大程序有实现支持这些功能的所有代码，向用户应用软件提供一些接口，这些接口就是常说的系统API函数。这个大程序会在处理器的特权模式下运行，这个模式通常通常被称为宏内核模式。</p>
 <img src="https://cdn.osrhu.xyz/images/os2.assets\image-20211219125335242.png">

<p>非层次关系，只是链接在一起。</p>
<p>过程：应用程序调用内存分配的API，处理器切换到特权模式，内核内存管理代码按照算法分配内存，内存首地址放回给API函数，</p>
<p>处理器开始运行用户模式下的应用程序，应用程序得到这一块内存的首地址就可以使用这个内存。、</p>
<p>缺点：它没有模块化，没有扩展性、没有移植性，高度耦合在一起，一旦其中一个组件有漏洞，内核中所有的组件可能都会出问题。</p>
<h3 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h3><p>提倡内核功能尽可能少，仅仅只有进程调度、处理中断、内存空间映射、做成一个个服务进程。</p>
<p>微内核定义了一种良好的进程间通信的机制—消息。</p>
 <img src="https://cdn.osrhu.xyz/images/os2.assets\image-20211219130223512.png">

<p>缺点：微内核各个服务进程的切换开销不小。</p>
<p>优点：代码量少；相当好的伸缩性、扩展性，因为那些系统功能只是一个进程，可以随时拿掉一个服务进程以减少系统功能，或者增加几个服务进程以增强系统功能。</p>
<h2 id="分离硬件的相关性"><a href="#分离硬件的相关性" class="headerlink" title="分离硬件的相关性"></a>分离硬件的相关性</h2><p>进程是操作系统开发者为了实现多任务而提出的，并让每个进程在 CPU 上运行一小段时间，这样就能实现多任务同时运行的假象。</p>
<p>要实现这种假象，就要实现下面这两种机制：</p>
<ul>
<li>进程调度，轮转算法、优先级算法等</li>
<li>进程切换，主要动作是保存当前进程的机器上下文，装载新进程的机器上下文。不同的硬件平台的机器上下文是不同的。</li>
</ul>
<hr>
<p>以上就是了为了设计自己的内核而铺垫。</p>
<p>操作系统内核分为三个大层：</p>
<ol>
<li>内核接口层<ul>
<li>UNIX 接口</li>
</ul>
</li>
<li>内核功能层<ul>
<li>进程管理: 主要是实现进程的创建、销毁、调度进程，当然这要设计几套数据结构用于表示进程和组织进程，还要实现一个简单的进程调度算法。</li>
<li>内存管理: 在内核功能层中只有内存池管理，分两种内存池：页面内存池和任意大小的内存池</li>
<li>中断管理: 把一个中断回调函数安插到相关的数据结构中，一旦发生相关的中断就会调用这个函数。</li>
<li>设备管理: 需要用一系列的数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备，最后把它们组织在一起，还要实现创建设备、销毁设备、访问设备的代码，这些代码最终会调用设备驱动程序，达到操作设备的目的</li>
</ul>
</li>
<li>内核硬件层<ul>
<li>初始化，初始化代码是内核被加载到内存中最先需要运行的代码，例如初始化少量的设备、CPU、内存、中断的控制、内核用于管理的数据结构</li>
<li>CPU 控制，提供 CPU 模式设定、开、关中断、读写 CPU 特定寄存器等功能的代码</li>
<li>中断处理，保存中断时机器的上下文，调用中断回调函数，操作中断控制器等</li>
<li>物理内存管理，提供分配、释放大块内存，内存空间映射，操作 MMU、Cache 等</li>
<li>平台其它相关的功能，有些硬件平台上有些特殊的功能，需要额外处理一下</li>
</ul>
</li>
</ol>
 <img src="https://cdn.osrhu.xyz/images/os2.assets\image-20211219131650565.png">

<p>​                                                                                                                            设计的内核结构</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏内核和单体架构一致，微内核和SOA架构一致，设计的内核结构更像是微服务架构。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>os3</title>
    <url>/os/os3/</url>
    <content><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>实模式、保护模式、长模式（主要是因为X86 CPU的历史包袱，为了向下兼容，让老的程序仍然可以在新的CPU上执行。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int* addr = (int*)0;</span><br><span class="line">    cli(); //关中断</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = 0;</span><br><span class="line">        addr++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实模式下，这段代码可以运行。实模式下，没有现代操作系统的概念。</p>
<p>第一，CPU 对任何指令不加区分地执行；</p>
<p>第二，CPU 对访问内存的地址不加限制。</p>
<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>实模式又称为实地址模式，实模式的“实”体现在两个方面。一个是指令功能，一个是内存地址。</p>
<p>x86 CPU实模式下的CPU</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219144614185.png">



 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219151125889.png">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data SEGMENT ;定义一个数据段存放Hello World!</span><br><span class="line">    hello  DB &#x27;Hello World!$&#x27; ;注意要以$结束</span><br><span class="line">data ENDS</span><br><span class="line">code SEGMENT ;定义一个代码段存放程序指令</span><br><span class="line">    ASSUME CS:CODE,DS:DATA ;告诉汇编程序，DS指向数据段，CS指向代码段</span><br><span class="line">start:</span><br><span class="line">    MOV AX,data  ;将data段首地址赋值给AX                </span><br><span class="line">    MOV DS,AX    ;将AX赋值给DS，使DS指向data段</span><br><span class="line">    LEA DX,hello ;使DX指向hello首地址</span><br><span class="line">    MOV AH,09h   ;给AH设置参数09H，AH是AX高8位，AL是AX低8位，其它类似</span><br><span class="line">    INT 21h      ;执行DOS中断输出DS指向的DX指向的字符串hello</span><br><span class="line">    MOV AX,4C00h ;给AX设置参数4C00h</span><br><span class="line">    INT 21h      ;调用4C00h号功能，结束程序</span><br><span class="line">code ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<h2 id="实模式中断"><a href="#实模式中断" class="headerlink" title="实模式中断"></a>实模式中断</h2><ul>
<li>中断控制器给CPU发送一个电子信号，CPU会对这个信号做出应答。随后中断控制器会将中断号发送给CPU，这是硬件中断。</li>
<li>CPU执行了INT指令，指令后面会跟随一个常数，这个常数就是软中断号。这称为软件中断。</li>
</ul>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>内存中放一个中断向量表，这个表的地址和长度由 CPU 的特定寄存器 IDTR 指向</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219152049893.png">

<p>IDTR + 中断号 —&gt; 中断代码段基址、段内偏移</p>
<h2 id="保护模式–对CPU进行抽象虚拟化处理"><a href="#保护模式–对CPU进行抽象虚拟化处理" class="headerlink" title="保护模式–对CPU进行抽象虚拟化处理"></a>保护模式–对CPU进行抽象虚拟化处理</h2><h3 id="保护模式寄存器"><a href="#保护模式寄存器" class="headerlink" title="保护模式寄存器"></a>保护模式寄存器</h3> <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219152322519.png">



<h3 id="保护模式特权级"><a href="#保护模式特权级" class="headerlink" title="保护模式特权级"></a>保护模式特权级</h3><p>为了区分哪些指令（如 in、out、cli）和哪些资源（如寄存器、I/O 端口、内存地址）可以被访问，CPU 实现了特权级。</p>
<p>特权级分为 4 级，R0~R3，每个特权级执行指令的数量不同，R0 可以执行所有指令，R1、R2、R3 依次递减，它们只能执行上一级指令数量的子集。而内存的访问则是靠后面所说的段描述符和特权级相互配合去实现的。如下图.</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219152806855.png">

<h2 id="保护模式段描述符"><a href="#保护模式段描述符" class="headerlink" title="保护模式段描述符"></a>保护模式段描述符</h2> <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219153303218.png">

<p>多个段描述符在内存中形成全局段描述符表，该表的基地址和长度由 CPU 和 GDTR 寄存器指示。如下图所示。</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219153351327.png">



<h2 id="保护模式段选择子"><a href="#保护模式段选择子" class="headerlink" title="保护模式段选择子"></a>保护模式段选择子</h2><p>CS,SS寄存器</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219153543835.png">

<p>通常情况下，CS 和 SS 中 RPL 就组成了 CPL（当前权限级别），所以常常是 RPL=CPL，进而 CPL 就表示发起访问者要以什么权限去访问目标段，当 CPL 大于目标段 DPL 时，则 CPU 禁止访问，只有 CPL 小于等于目标段 DPL 时才能访问。保护模式平坦模型</p>
<h2 id="保护模式平坦模式"><a href="#保护模式平坦模式" class="headerlink" title="保护模式平坦模式"></a>保护模式平坦模式</h2><p>分段模型有很多缺陷，现代操作系统都会使用分页模型。</p>
<p>CPU 32 位的寄存器最多只能产生 4GB 大小的地址，而一个段长度也只能是 4GB，所以我们把所有段的基地址设为 0，段的长度设为 0xFFFFF，段长度的粒度设为 4KB，这样所有的段都指向同一个（0~4GB-1）字节大小的地址空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">;第一个段描述符CPU硬件规定必须为0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">;段基地址=0，段长度=0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=1,C=1,R=1,A=0</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">;段基地址=0，段长度=0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=0,C=0,R=1,A=0</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure>

<p>段长度需要和 G 位配合，若 G 位为 1 则段长度等于 0xfffff 个 4KB。上面段描述符的 DPL=0，这说明需要最高权限即 CPL=0 才能访问。</p>
<h2 id="保护模式中断"><a href="#保护模式中断" class="headerlink" title="保护模式中断"></a>保护模式中断</h2><p>保护模式下，中断需要做检查跟特权级的切换。因此就需要扩展中断向量表的信息。</p>
<p>每个中断用一个中断门描述符来表示，简称为中断门。</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219155018402.png">

<p>保护模式要实现中断，也必须在内存中有一个中断向量表，同样是由 IDTR 寄存器指向，只不过中断向量表中的条目变成了中断门描述符，如下图所示。</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219155113659.png">

<h2 id="切换到保护模式"><a href="#切换到保护模式" class="headerlink" title="切换到保护模式"></a>切换到保护模式</h2><p>x86 CPU 在第一次加电和每次 reset 后，都会自动进入实模式，要想进入保护模式，就需要程序员写代码实现从实模式切换到保护模式。切换到保护模式的步骤如下。</p>
<ol>
<li><p>准备全局段描述符表—-代码段和数据段，基地址0,段长度0xfffff</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure></li>
<li><p>加载设置 GDTR 寄存器，使之指向全局段描述符表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lgdt [GDT_PTR]</span><br></pre></td></tr></table></figure></li>
<li><p>设置 CR0 寄存器，开启保护模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;开启 PE</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0                      ; CR0.PE =1</span><br><span class="line">mov cr0, eax         </span><br></pre></td></tr></table></figure></li>
<li><p>进行长跳转，加载 CS 段寄存器，即段选择子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="长模式"><a href="#长模式" class="headerlink" title="长模式"></a>长模式</h2><p>​    长模式又名AMD64</p>
<h2 id="长模式寄存器"><a href="#长模式寄存器" class="headerlink" title="长模式寄存器"></a>长模式寄存器</h2><p>长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219160349511.png">

<h2 id="长模式段描述符"><a href="#长模式段描述符" class="headerlink" title="长模式段描述符"></a>长模式段描述符</h2><p>长模式依然具备保护模式绝大多数特性，如特权级和权限检查。</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219160412754.png">

<p>在长模式下，CPU 不再对段基址和段长度进行检查，只对 DPL 进行相关的检查，这个检查流程和保护模式下一样。当描述符中的 L=1，D/B=0 时，就是 64 位代码段，DPL 还是 0~3 的特权级。然后有多个段描述在内存中形成一个全局段描述符表，同样由 CPU 的 GDTR 寄存器指向。</p>
<p>长模式下的段描述符表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ex64_GDT:</span><br><span class="line">null_dsc:  dq 0</span><br><span class="line">;第一个段描述符CPU硬件规定必须为0</span><br><span class="line">c64_dsc:dq 0x0020980000000000  ;64位代码段</span><br><span class="line">;无效位填0</span><br><span class="line">;D/B=0,L=1,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=1,C=0,R=0,A=0</span><br><span class="line">d64_dsc:dq 0x0000920000000000  ;64位数据段</span><br><span class="line">;无效位填0</span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=0,C/E=0,R/W=1,A=0</span><br><span class="line">eGdtLen   equ $ - null_dsc  ;GDT长度</span><br><span class="line">eGdtPtr:dw eGdtLen - 1  ;GDT界限</span><br><span class="line">     dq ex64_GDT</span><br></pre></td></tr></table></figure>

<h2 id="长模式下的中断门描述符的格式"><a href="#长模式下的中断门描述符的格式" class="headerlink" title="长模式下的中断门描述符的格式"></a>长模式下的中断门描述符的格式</h2> <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219161048011.png">

<p>长模式弱化段模式管理，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 MMU。</p>
<p>​        在没有使用的虚拟内存管理（Virtual Memory Management）技术机器上，虚拟地址被直接送到内存总线上，使具有相同地址的物理存储器被读写。而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到内存管理单元MMU。他由一个或一组芯片组成，一般存在与协处理器中，其功能是把虚拟地址映射为物理地址。</p>
<p>下面这张图就是描述虚拟地址/物理地址和CPU核、MMU、内存之间的关系。</p>
 <img src="https://cdn.osrhu.xyz/images/os3.assets\image-20211219162201393.png">

<p>参考：<a href="https://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-MMU.html">https://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-MMU.html</a></p>
<p>参考：<a href="https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-1/protect_mode.html">https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-1/protect_mode.html</a></p>
<hr>
<p>实模式，保护模式，长模式，逐渐演进</p>
<p>1、实模式：<br>(1)代码段地址+左移4位+ IP = 取指<br>数据段+左移4位+ 通用寄存器值 = 数据地址<br>栈段SS+左移4位 + SP = 栈地址<br>(2)实模式中断：<br>中断号+ IDTR 寄存器(指向中断表的地址和长度) —&gt; 根据中断号，找到中断表中的对应条目 —&gt; 解析出中断函数基地址填充CS、中断函数偏移填充IP —&gt; 响应中断。</p>
<p>2、保护模式：<br>(1)保护模式寄存器：通用寄存器，IP，SP 16位-&gt;32位。添加了EFLAGS cpu标志寄存器和几个cpu控制寄存器。 CS DS SS 中改为存放内存段的索引，用于寻找内存中的段描述符。<br>(2)保护模式下，R0 – R3的特权级别访问。通过内存中存放64位段描述符实现特权划分，段地址寻址。<br> CS | DS | SS （段描述符索引）+ GDTR（指向全局段描述符表基地址） – &gt; 找到段描述符 –&gt; 解析代码段还是数据段，地址，访问权限<br> 其中影子寄存器 : 通过硬件实现，是段描述符的高速缓存, 防止反复读内存，提高效率。<br> 权限问题：当前执行程序的CS RPL、SS RPL = CPL, 要访问的段描述符中拿到DPL， CPL &gt; DPL 禁止程序访问目标段， CPL &lt;= DPL , 可以访问<br>(3)保护模式的平坦模型: 段基址为0，段长度为4G的特殊段管理模式，规避历史原因导致的分段模型缺陷。<br>(4)保护模式中断:中断号+ IDTR 寄存器(指向中断表) —&gt; 根据中断号，找到中断表指向的内存中的中断门描述符 —&gt; 中断门和中断描述符中段选择子的权限检查–&gt; 中断门描述符中目标代码段选择子填充CS， 目标代码段偏移填充EIP —&gt; 响应中断。<br>权限问题：当前CPL小于等于中断门DPL，才可进中断门，当前CPL，大于段选择子的DPL，则设置CPL=段选择子DPL。<br>例：当前运行代码CPL=R3级别，遇R3中断门进门，执行特权级中断程序R0，此时CRL=R0。</p>
<p>(5) 切换保护模式： 准备全局描述附表GDT，<br>GDTR指向GDT，<br>设置CR0开启保护模式，<br>执行长跳转,CPU根据8索引值索引GDT中第二条数据，加载CS</p>
<p>3、长模式：<br>（1）寄存器扩展到64位<br>（2）长模式段描述符, L=1，D/B=0 时是64 位代码段， L ， D/B, 无效是数据段<br>（3）长模式中断：中断们描述符比保护模式多了8字节64位，用于存放64位的目标代码段偏移多出来的高32位。<br>其他中断过程同保护模式。<br>（4）长模式切换：准备长模式全局段描述符表,<br>准备长模式下的MMU页表,开启分页模式<br>CR3指向页表物理地址<br>GDTR指向全局段描述符表<br>IA32_EFER寄存器第8位开启长模式，CR0寄存器= 0x31开启保护模式和分页模式<br>进行跳转，索引GDT， 加载 CS 段寄存器，刷新其影子寄存器</p>
<p>（5）长模式弱化段模式管理，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 MMU，分页管理。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>os4</title>
    <url>/os/os4/</url>
    <content><![CDATA[<h1 id="地址转化"><a href="#地址转化" class="headerlink" title="地址转化"></a>地址转化</h1><h2 id="MMU工作原理图"><a href="#MMU工作原理图" class="headerlink" title="MMU工作原理图"></a>MMU工作原理图</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226111114632.png">

<h2 id="分页模型框架"><a href="#分页模型框架" class="headerlink" title="分页模型框架"></a>分页模型框架</h2><p>把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了现代内存管理模式——分页模型。</p>
 <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226111131637.png">

<h2 id="CPU地址转换表"><a href="#CPU地址转换表" class="headerlink" title="CPU地址转换表"></a>CPU地址转换表</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226111220571.png">

<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226111313390.png">

<h2 id="保护模式下的分页–4KB页"><a href="#保护模式下的分页–4KB页" class="headerlink" title="保护模式下的分页–4KB页"></a>保护模式下的分页–4KB页</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226111944619.png">

 <img src="https://cdn.osrhu.xyz/images/os4.assets\361c48e1876a412f9ff9f29bf2dbecc9.jpg">

<h2 id="保护模式下的分页–4MB页"><a href="#保护模式下的分页–4MB页" class="headerlink" title="保护模式下的分页–4MB页"></a>保护模式下的分页–4MB页</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226112403492.png">

 <img src="https://cdn.osrhu.xyz/images/os4.assets\9a4afdc60b790c3e2b7e94b0c7fd4208.jpg">

<h2 id="长模式下的分页——4KB-页"><a href="#长模式下的分页——4KB-页" class="headerlink" title="长模式下的分页——4KB 页"></a>长模式下的分页——4KB 页</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\ecdea93c2544cf9c1d84461b602b03c9.jpg">



<p>4KB 分页模式下的 CR3、顶级页目录项、页目录指针项、页目录项的格式，格式如下图。</p>
 <img src="https://cdn.osrhu.xyz/images/os4.assets\e342246f5cfa21c5b5173b9e494bdc55.jpg">

<h2 id="长模式下的分页——2MB-页"><a href="#长模式下的分页——2MB-页" class="headerlink" title="长模式下的分页——2MB 页"></a>长模式下的分页——2MB 页</h2> <img src="https://cdn.osrhu.xyz/images/os4.assets\image-20211226130814042.png">



<p>2MB 分页模式下的 CR3、顶级页目录项、页目录指针项、页目录项的格式，格式如下图。</p>
 <img src="https://cdn.osrhu.xyz/images/os4.assets\457f6965d0f25bf64bfb9ec698ab7e0b.jpg">

<h2 id="MMU地址转化失败"><a href="#MMU地址转化失败" class="headerlink" title="MMU地址转化失败"></a>MMU地址转化失败</h2><p>MMU执行的操作如下：</p>
<p>1.MMU停止定制转化</p>
<p>2.MMU把转化失败的虚拟地址写入CPU的CR2寄存器</p>
<p>3.MMU出发CPU的14号中断，使CPU停止执行当前指令</p>
<p>4.CPU开始执行14号中断的处理代码，代码会检查原因，处理好页表数据返回。</p>
<p>5.CPU中断返回继续执行MMU地址转化失败时的指令。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>pta</title>
    <url>/pta/1020/</url>
    <content><![CDATA[<h1 id="1020-Tree-Traversals-25-分"><a href="#1020-Tree-Traversals-25-分" class="headerlink" title="1020 Tree Traversals (25 分)"></a><strong>1020 Tree Traversals (25 分)</strong></h1><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1 6 3 5 7 2</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p>做题思路：</p>
<p>把输入值放入pos和in数组，要记录in的值的位置，方便找root的位置，找到后左右递归遍历建立一棵树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 40;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">unordered_map&lt;int, int&gt; pos, l, r;</span><br><span class="line">int postorder[N], inorder[N];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">vector&lt;int&gt;ans;</span><br><span class="line"></span><br><span class="line">int build(int il, int ir, int pl, int pr)</span><br><span class="line">&#123;</span><br><span class="line">    int root = postorder[pr];</span><br><span class="line"></span><br><span class="line">    int k = pos[root];</span><br><span class="line"></span><br><span class="line">    if(il &lt; k) l[root] = build(il, k-1, pl, pl + k - 1 - il);</span><br><span class="line">    if(k &lt; ir) r[root] = build(k+1, ir, pr - ir + k, pr-1);</span><br><span class="line"></span><br><span class="line">    return root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs(int root)</span><br><span class="line">&#123;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int t = q.front();</span><br><span class="line">        ans.push_back(t);</span><br><span class="line">        q.pop();</span><br><span class="line">        if(l.count(t)) q.push(l[t]);</span><br><span class="line">        if(r.count(t)) q.push(r[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; postorder[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; inorder[i];</span><br><span class="line">        pos[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    int root = build(0, n-1, 0, n-1);</span><br><span class="line"></span><br><span class="line">    bfs(root);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; ans.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if(i) cout &lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt; ans[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pta</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
</search>
